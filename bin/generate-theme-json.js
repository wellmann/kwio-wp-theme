#!/usr/bin/env node

const _ = require('lodash');
const { extract } = require('custom-property-extract');
const fs = require('fs');
const path = require('path');
const sass = require('sass');
const themeJson = require('../theme.edit.json');

const humanizeSlug = (string) => string.replace(/-/g, ' ').replace(/\b\w/g, (s) => s.toUpperCase());

const transformPropertyToArray = (updatedThemeJson, rootKey, key, value, valueKey) => {
  const objectKeys = [rootKey, ...key.replace(/^--/, '').split('--')];
  const slug = objectKeys.pop(); // "primary" from --color--palette--primary: #111;
  const name = humanizeSlug(slug);
  const objectValue = _.get(updatedThemeJson, objectKeys, []);

  objectValue.push({
    name,
    slug,
    [valueKey]: value
  });

  _.set(updatedThemeJson, objectKeys, objectValue);
};

const transformPropertyToPrimitive = (updatedThemeJson, rootKey, key, value) => {
  const objectKeys = [rootKey, ...key.replace(/^--/, '').split('--')];

  _.set(updatedThemeJson, objectKeys, value);
};

const transformFluidFontSizes = (updatedThemeJson, rootKey, key, value) => {
  const objectKeys = [rootKey, ...key.replace(/^--/, '').split('--')];
  objectKeys.pop(); // "min" from --typography--fontSizes--100--min: 16px;
  const slug = objectKeys.pop(); // "100" from --typography--fontSizes--100--min: 16px;
  const name = humanizeSlug(slug);
  const objectValue = _.get(updatedThemeJson, objectKeys, []);

  const minIndex = updatedThemeJson?.settings?.typography?.fontSizes?.findIndex(({ slug: s }) => s === slug);
  if (minIndex > -1) {
    updatedThemeJson.settings.typography.fontSizes[minIndex].size = value;
    updatedThemeJson.settings.typography.fontSizes[minIndex].fluid.max = value;
  } else {
    objectValue.push({
      name,
      slug,
      size: value,
      fluid: {
        min: value
      }
    });
  }

  _.set(updatedThemeJson, objectKeys, objectValue);
};

const result = sass.compile(path.resolve('./assets/scss/_tokens.scss'));
const customProperties = extract(result.css, {
  syntax: 'css',
  source: 'content'
});

let updatedThemeJson = {};
Object.entries(customProperties).forEach(([key, valueArray]) => {
  const value = valueArray[0];
  if (!value) {
    return;
  }

  switch (true) {
    case key.includes('duotone'):
      transformPropertyToArray(updatedThemeJson, 'settings', key, value, 'colors');
      break;
    case key.includes('gradients'):
      transformPropertyToArray(updatedThemeJson, 'settings', key, value, 'gradient');
      break;
    case key.includes('palette'):
      transformPropertyToArray(updatedThemeJson, 'settings', key, value, 'color');
      break;
    case key.includes('contentSize'):
      transformPropertyToPrimitive(updatedThemeJson, 'settings', key, value);
      break;
    case key.includes('wideSize'):
      transformPropertyToPrimitive(updatedThemeJson, 'settings', key, value);
      break;
    case key.includes('spacingSizes'):
      transformPropertyToArray(updatedThemeJson, 'settings', key, value, 'size');
      break;
    case key.includes('fontSizes'):
      transformFluidFontSizes(updatedThemeJson, 'settings', key, value);
      break;
    case key.includes('fontFamilies'):
      transformPropertyToArray(updatedThemeJson, 'settings', key, value, 'fontFamily');
      break;
    case key.includes('--custom--'):
      transformPropertyToPrimitive(updatedThemeJson, 'settings', key, value);
      break;
    case key.includes('blockGap'):
      transformPropertyToPrimitive(updatedThemeJson, 'styles', key, value);
      break;
  }
});

const newThemeJson = _.merge(
  { description: 'Do not edit! This file is generated by postbuild script. Edit theme.edit.json instead.' },
  themeJson,
  updatedThemeJson
);

fs.writeFile(path.resolve('./theme.json'), JSON.stringify(newThemeJson, null, 2), (err) => {
  if (err) {
    console.log(`\x1b[31m${err.message}\x1b[0m`);
    process.exit(1);
  }

  console.log(`\x1b[32mtheme.json has been created successfully.\x1b[0m`);
});